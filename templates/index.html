<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <link rel="manifest" href="/static/manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/static/xiaoba_192.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">
    <title data-i18n="app.title">Project N.E.K.O.</title>
    
    <!-- HTML/JS 通用初始化工具（封装 waitForRequestInit 等） -->
    <script src="/static/bundles/react_init.js"></script>

    <!-- 加载统一的 request 模块（ES Module） -->
    <script type="module" src="/static/bundles/request.global.js"></script>
    
    <!-- 加载首页 API 封装模块（ES Module，可选） -->
    <!-- 构建命令：npm run build:global -->
    <script type="module" src="/static/bundles/request.api.global.js"></script>

    <script type="module">
    // 初始化消息队列（在组件挂载前缓存消息）
    if (!window.__statusToastQueue) {
        window.__statusToastQueue = [];
    }
    
    // 提供临时的 showStatusToast 函数，在组件挂载前缓存消息
    if (typeof window.showStatusToast !== 'function') {
        window.showStatusToast = function(message, duration = 3000) {
        console.log('[Status Toast] 组件未挂载，消息已加入队列:', message);
        window.__statusToastQueue.push({ message, duration });
        };
    }

    // 重要：先导入 React 和 ReactDOM，确保它们先初始化
    import React from "/static/bundles/react.js";
    import { createRoot } from "/static/bundles/react-dom-client.js";
    // 然后导入组件（组件依赖 React 和 ReactDOM）
    import { StatusToast } from "/static/bundles/StatusToast.js";
    import { Button } from "/static/bundles/Button.js";
    
    // 导入 Modal 组件（支持命名导出和默认导出）
    let Modal;
    import("/static/bundles/Modal.js").then(module => {
        Modal = module.Modal || module.default;
        console.log("[Modal] Modal 组件导入成功:", typeof Modal);
        // 导入成功后尝试挂载
        mountModal();
    }).catch(error => {
        console.error("[Modal] Modal 组件导入失败:", error);
    });

    // 优先挂载 StatusToast（确保在 app.js 执行前就绪）
    function mountStatusToast() {
        const container = document.getElementById("status-toast");
        if (container) {
            try {
                const root = createRoot(container);
                // 确保 ReactDOM 已经初始化 hooks dispatcher
                // 通过立即渲染一个空组件来触发初始化
                root.render(React.createElement(StatusToast));
                console.log("StatusToast 组件已挂载");
            } catch (error) {
                console.error("StatusToast 挂载失败:", error);
                // 如果失败，延迟重试
                setTimeout(mountStatusToast, 100);
            }
        } else {
            console.error("StatusToast 容器不存在，延迟重试...");
            // 如果容器不存在，延迟重试
            setTimeout(mountStatusToast, 50);
        }
    }

    // ExampleButton 相关逻辑已移除，示例按钮不再在生产页面中使用

    // 挂载 Modal 组件
    function mountModal() {
        console.log("[Modal] 开始挂载 Modal 组件...");
        console.log("[Modal] Modal 变量类型:", typeof Modal);
        
        if (!Modal) {
            console.warn("[Modal] Modal 组件尚未导入，延迟重试...");
            setTimeout(mountModal, 100);
            return;
        }
        
        const container = document.getElementById("modal-container");
        console.log("[Modal] 容器查找结果:", container);
        if (container) {
            try {
                console.log("[Modal] 创建 React Root...");
                const root = createRoot(container);
                console.log("[Modal] 渲染 Modal 组件...");
                root.render(React.createElement(Modal));
                console.log("✅ Modal 组件已挂载");
            } catch (error) {
                console.error("❌ Modal 挂载失败:", error);
                console.error("错误堆栈:", error.stack);
                // 如果失败，延迟重试
                setTimeout(mountModal, 100);
            }
        } else {
            console.error("❌ Modal 容器不存在，延迟重试...");
            // 如果容器不存在，延迟重试
            setTimeout(mountModal, 50);
        }
    }

    // 通用 Button 挂载辅助函数，避免重复代码
    function mountReactButton(containerId, buttonProps, children) {
        const container = document.getElementById(containerId);
        if (!container) {
            return;
        }
        try {
            const root = createRoot(container);
            root.render(
                React.createElement(
                    Button,
                    buttonProps,
                    ...children,
                ),
            );
        } catch (error) {
            console.error(`[Button] 挂载 ${buttonProps && buttonProps.id ? buttonProps.id : containerId} 失败:`, error);
        }
    }

    // 挂载通用 Button 组件到现有按钮位置
    function mountButtons() {
        // 清空全部截图按钮
        mountReactButton(
            "clear-all-screenshots-container",
            {
                id: "clear-all-screenshots",
                variant: "danger",
                size: "sm",
            },
            [
                React.createElement("span", { "data-i18n": "chat.clearAll" }, "清空全部"),
            ],
        );

        // 文本发送按钮
        mountReactButton(
            "textSendButton-container",
            {
                id: "textSendButton",
                variant: "primary",
                size: "md",
            },
            [
                React.createElement("img", {
                    src: "/static/icons/send_icon.png",
                    alt: "",
                }),
                React.createElement("span", { "data-i18n": "chat.send" }, "发送"),
            ],
        );

        // 截图 / 拍照按钮
        mountReactButton(
            "screenshotButton-container",
            {
                id: "screenshotButton",
                variant: "secondary",
                size: "md",
            },
            [
                React.createElement("img", {
                    src: "/static/icons/screenshot_icon.png",
                    alt: "",
                }),
                React.createElement(
                    "span",
                    { className: "desktop-text", "data-i18n": "chat.screenshot" },
                    "截图",
                ),
                React.createElement(
                    "span",
                    { className: "mobile-text", "data-i18n": "chat.takePhoto" },
                    "拍照",
                ),
            ],
        );
    }

    function mountComponents() {
        // 优先挂载 StatusToast
        mountStatusToast();
        // 挂载 Modal（尽早挂载，确保全局 API 可用）
        mountModal();
        // 然后挂载其他组件
        mountButtons();
    }

    // 立即尝试挂载（不等待 DOMContentLoaded），确保尽早挂载
    if (document.readyState === "loading") {
        // 如果还在加载，立即挂载 StatusToast，Modal 会在导入完成后自动挂载
        mountStatusToast();
        // 其余组件在 DOMContentLoaded 后挂载
        document.addEventListener("DOMContentLoaded", () => {
            mountButtons();
        });
    } else {
        // 如果已经加载完成，立即挂载所有组件
        mountComponents();
        // mountModal() 会在 Modal 导入成功后自动调用（如果还没挂载）
    }
    </script>
    
    <!-- i18next 加载器（统一处理 CDN 加载和初始化） -->
    <script src="/static/i18n-i18next.js"></script>
    <!-- 
        统一的 request 模块初始化
        - 加载 request.global.js（打包了 axios 和 axios-auth-refresh）
        - 自动初始化 window.request、window.buildApiUrl 等工具函数
        - 旧版 JS 代码应使用 window.request 或 window.buildApiUrl 等工具函数
        - 如需自定义后端地址，可在此处显式设置：
          window.API_BASE_URL = 'http://your-backend-host:port';
          window.STATIC_SERVER_URL = window.API_BASE_URL;
        
        首页 API 封装模块（request.api.global.js）
        - 提供 window.RequestAPI 对象，封装常用的 API 调用
        - 使用方式：await window.RequestAPI.getPageConfig()
        - 详见：react_web/app/api/request.api.ts
    -->
    <!-- 
        注意：Modal 对话框功能已迁移到 React 组件
        - 全局 API: window.showAlert, window.showConfirm, window.showPrompt
        - 由 Modal 组件自动提供，无需加载 common_dialogs.js
    -->
    <style>
        *:focus {
            outline: none !important;
            box-shadow: none !important; 
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            /*background: #fff;*/
            background: transparent;
            color: #222;
            font-family: 'Segoe UI', Arial, sans-serif;
            pointer-events: none; /* 允许鼠标事件穿透 */
            overflow: hidden; /* 防止出现滚动条 */
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 0.85;
                transform: translateY(0);
            }
        }
        
        /* Status 气泡框样式已迁移到 StatusToast 组件 CSS 文件 */
        
        /* 全局按钮样式 - 防止文字被选中 */
        button {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        /* 防止所有图标、图片、按钮内容被选中和拖动 */
        img {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-user-drag: none;
            -khtml-user-drag: none;
            -moz-user-drag: none;
            -o-user-drag: none;
            pointer-events: none; /* 图标不响应鼠标事件 */
        }
        
        /* 按钮内的所有内容（包括emoji图标）不可选中 */
        button * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            pointer-events: none; /* 按钮内部元素不响应事件，由按钮本身处理 */
        }

        /* 响应式设计 */
        @media (max-width: 480px) {
            .container {
                width: 100%;
                height: 100%;
            }
        }

        #live2d-container {
            position: fixed;
            right: 0px;
            bottom: 0px;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            background: none;
            opacity: 1;
            overflow: hidden;
            visibility: visible;
            transition: all 1s ease-in-out, height 0ms 1s, width 0ms 1s, visibility 0ms 1s;
        }

        #live2d-container.minimized {
            right: -800px; /* 向右侧移出屏幕 */
            opacity: 0;
            visibility: hidden;
        }

        #live2d-canvas {
            right: 0;
            bottom: 0;
            pointer-events: none;
            /*width: auto;*/
            /*height: auto;*/
            display: block;
            opacity: 1;
            visibility: visible;
            background: transparent;
        }

        #live2d-canvas.minimized {
            opacity: 0;
            visibility: hidden;
        }

        #chat-container {
            margin-bottom: 50px;
            pointer-events: auto; /* 恢复鼠标交互 */
            position: fixed;
            left: 20px;
            bottom: 20px;
            width: 400px;
            max-height: 500px;
            height: 500px;
            /* Fluent Design Acrylic 材质 */
            background: rgba(255, 255, 255, 0.65);
            backdrop-filter: saturate(180%) blur(20px);  /* Fluent Design 标准模糊值 */
            -webkit-backdrop-filter: saturate(180%) blur(20px);
            border-radius: 8px;  /* Fluent Design 标准圆角 */
            border: 1px solid rgba(255, 255, 255, 0.18);  /* 微妙的高光边框 */
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
            z-index: 20;
            /* Fluent Design 多层阴影创造深度 */
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.04),
                0 8px 16px rgba(0, 0, 0, 0.08),
                0 16px 32px rgba(0, 0, 0, 0.04);
            scroll-behavior: smooth;
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease, height 0.3s ease, max-height 0.3s ease, padding 0.3s ease, box-shadow 0.2s ease;
        }

        /* 内部内容包裹器，负责滚动 - Fluent Design */
        #chat-content-wrapper {
            pointer-events: auto;
            flex-grow: 1;
            padding: 16px;
            padding-top: 48px;
            overflow-y: auto;
            scroll-behavior: smooth;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            opacity: 1;
            visibility: visible;
            background: rgba(249, 249, 249, 0.7);  /* Fluent Design 背景层 */
        }

        /* 切换按钮样式 - 更醒目的设计 */
        #toggle-chat-btn {
            pointer-events: auto; /* 恢复鼠标交互 */
            position: absolute; /* 绝对定位于容器内 */
            top: 8px;
            right: 8px;
            width: 24px;  /* 按钮尺寸以容纳图标 */
            height: 24px;  /* 按钮尺寸以容纳图标 */
            background: transparent; /* 透明背景，去掉深蓝色方框 */
            opacity: 1;
            border: none; /* 去掉边框 */
            border-radius: 0; /* 去掉圆角 */
            cursor: grab; /* 拖拽手势 */
            font-weight: bold;
            font-size: 14px; /* 改为固定像素值，确保一致性 */
            line-height: 24px; /* 与按钮高度一致，确保垂直居中 */
            text-align: center;
            color: #fff;
            z-index: 21; /* 确保在内容之上 */   
            padding: 0;
            user-select: none;
            box-shadow: none; /* 去掉阴影 */
            transition: all 0.3s ease;
        }
        
        #toggle-chat-btn:hover {
            transform: scale(1.1);
        }
        
        /* 聊天框标题 - Fluent Design 风格 */
        #chat-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 48px;
            background: rgba(255, 255, 255, 0.5);  /* 更透明的 Mica 效果 */
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);  /* Fluent Design 中性分隔线 */
            display: flex;
            align-items: center;
            padding: 0 16px;
            box-sizing: border-box;
            z-index: 21;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        /* 标题栏内的所有元素都不可选中 */
        #chat-header * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        #chat-title {
            font-size: 0.875rem;  /* Fluent Design 标准字号 14px */
            font-weight: 600;
            color: rgba(0, 0, 0, 0.9);  /* Fluent Design 高对比度文本 */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* 对话区提示框 */
        #chat-tooltip {
            position: absolute;
            top: 60px;
            left: 16px;
            background: rgba(68, 183, 254, 0.95);  /* 与主色调一致 #44b7fe */
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(68, 183, 254, 0.4);
            z-index: 22;
            pointer-events: none;
            animation: slideInBounce 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        #chat-tooltip.hidden {
            opacity: 0;
            transform: translateX(-20px);
            pointer-events: none;
        }

        #chat-tooltip::after {
            content: '';
            position: absolute;
            top: -6px;
            left: 20px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid rgba(68, 183, 254, 0.95);
        }

        @keyframes slideInBounce {
            0% {
                opacity: 0;
                transform: translateX(-30px) scale(0.8);
            }
            60% {
                opacity: 1;
                transform: translateX(5px) scale(1.05);
            }
            100% {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }
        
        /* 聊天消息样式 */
        #chatContainer {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .message {
            padding: 10px 14px;
            border-radius: 12px;
            max-width: 80%;
            word-wrap: break-word;
            line-height: 1.5;
            font-size: 0.95rem;
            animation: fadeIn 0.3s ease;
        }
        
        .message.user {
            align-self: flex-end;
            background: #44b7fe;  /* 与按钮一致的浅蓝色 */
            color: #fff;
            margin-left: auto;
            border-bottom-right-radius: 4px;
        }
        
        .message.gemini {
            align-self: flex-start;
            background: rgba(68, 183, 254, 0.12);  /* 与主色调协调的浅蓝背景 */
            color: #333;
            margin-right: auto;
            border-bottom-left-radius: 4px;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* 文本输入区域样式 - Fluent Design */
        #text-input-area {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.5);  /* Fluent Acrylic */
            border-top: 1px solid rgba(0, 0, 0, 0.06);  /* 中性分隔线 */
            box-sizing: border-box;
            transition: all 0.3s ease;
            position: relative;
            z-index: 25;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        /* 文本输入区域内的所有元素（除了输入框）不可选中 */
        #text-input-area * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        /* 语音模式下隐藏文本输入区 */
        #text-input-area.hidden {
            display: none;
        }
        
        /* 截图缩略图容器 - 横向滚动布局 */
        #screenshot-thumbnail-container {
            display: none;
            flex-direction: column;
            gap: 6px;
            padding: 8px;
            background: rgba(68, 183, 254, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(68, 183, 254, 0.2);
            animation: slideDown 0.3s ease;
        }
        
        #screenshot-thumbnail-container.show {
            display: flex;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* 截图列表头部 */
        #screenshots-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 4px;
        }
        
        #screenshots-title {
            font-size: 0.85rem;
            color: #44b7fe;
            font-weight: 600;
        }
        
        /* #clear-all-screenshots 按钮的视觉样式由 React Button 组件的 Button.css 提供 */
        
        /* 截图列表 - 横向滚动 */
        #screenshots-list {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 4px 0;
            scrollbar-width: thin;
            scrollbar-color: #ccc transparent;
        }
        
        #screenshots-list::-webkit-scrollbar {
            height: 6px;
        }
        
        #screenshots-list::-webkit-scrollbar-track {
            background: transparent;
        }
        
        #screenshots-list::-webkit-scrollbar-thumb {
            background: rgba(68, 183, 254, 0.4);
            border-radius: 3px;
        }
        
        #screenshots-list::-webkit-scrollbar-thumb:hover {
            background: rgba(68, 183, 254, 0.6);
        }
        
        /* 单个截图卡片 */
        .screenshot-item {
            position: relative;
            flex-shrink: 0;
            width: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        @keyframes slideOut {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(0.8);
            }
        }
        
        .screenshot-thumbnail {
            width: 100px;
            height: 75px;
            object-fit: cover;
            border-radius: 6px;
            border: 2px solid #ddd;
            background: white;
            transition: border-color 0.2s, transform 0.2s;
            cursor: pointer;
        }
        
        .screenshot-thumbnail:hover {
            border-color: #44b7fe;
            transform: scale(1.05);
        }
        
        .screenshot-remove {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: none;
            background: #dc3545;
            color: white;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, transform 0.2s;
            padding: 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .screenshot-remove:hover {
            background: #c82333;
            transform: scale(1.1);
        }
        
        .screenshot-index {
            font-size: 0.7rem;
            color: #44b7fe;
            background: white;
            padding: 2px 6px;
            border-radius: 10px;
            border: 1px solid rgba(68, 183, 254, 0.3);
        }
        
        #text-input-row {
            display: flex;
            gap: 8px;
            align-items: flex-start; /* 顶部对齐，确保上沿对齐 */
            position: relative;
            z-index: 1;
        }
        
        #textInputBox {
            pointer-events: auto;
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ccc;
            font-size: 0.9rem;
            background: #fff;
            color: #222;
            resize: none;
            /* 高度精确等于按钮组总高度，确保上沿和下沿对齐 */
            /* 发送按钮: padding 8px上下 + border 2px上下(透明) + 内容高度(图标22px) = 8+2+22+2+8 = 42px */
            /* gap: 6px */
            /* 截图按钮: padding 8px上下 + border 2px上下(蓝色) + 内容高度(图标22px) = 8+2+22+2+8 = 42px */
            /* 总高度: 42px + 6px + 42px = 90px */
            /* 由于box-sizing: border-box，边框包含在高度内 */
            height: 90px;
            box-sizing: border-box;
            cursor: text;
            caret-color: #222;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif;
            font-weight: 400;
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            /* 文本输入框需要能够选中文本 */
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
        }
        
        #textInputBox:focus {
            outline: none;
            border-color: #44b7fe;
            box-shadow: none;
        }
        
        #textInputBox:disabled {
            background: #f5f5f5;
            color: #999;
            cursor: not-allowed;
        }
        
        #button-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        /* #textSendButton 与 #screenshotButton 的视觉样式由 React Button 组件的 Button.css 提供 */
        
        /* 桌面端和移动端文本显示控制 */
        .desktop-text {
            display: inline;
        }
        
        .mobile-text {
            display: none;
        }

        /* --- 最小化状态 --- */
        #chat-container.minimized {
            background: rgba(68, 183, 254, 0.15);
            opacity: 1;
            width: 50px; /* 最小化宽度（正方形） */
            height: 50px; /* 最小化高度（正方形） */
            max-height: 50px;
            padding: 0; /* 移除内边距 */
            cursor: pointer; /* 让整个小方块可点击（虽然按钮也在） */
            border-radius: 50%; /* 圆形 */
            animation: breathingGlow 2s ease-in-out infinite;
        }

        #chat-container.minimized #chat-header {
            display: none;
        }

        #chat-container.minimized #chat-content-wrapper {
            /* 隐藏内容区域 */
            opacity: 0;
            visibility: hidden;
            height: 0; /* 确保不占空间 */
            padding: 0;
            overflow: hidden; /* 隐藏滚动条 */
        }

        #chat-container.minimized #text-input-area {
            display: none;
        }

        #chat-container.minimized #chat-tooltip {
            display: none;
        }

        #chat-container.minimized #toggle-chat-btn {
            /* 将按钮居中显示 */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* 保持相同的字体大小设置 */
            font-size: 14px;
            line-height: 24px;
            /* 防止hover效果在最小化状态下放大按钮 */
        }
        
        #chat-container.minimized #toggle-chat-btn:hover {
            transform: translate(-50%, -50%) scale(1.1);
        }
        
        /* 折叠状态下的呼吸特效动画 */
        @keyframes breathingGlow {
            0%, 100% {
                box-shadow: 0 0 8px rgba(68, 183, 254, 0.6);
            }
            50% {
                box-shadow: 0 0 16px rgba(68, 183, 254, 1);
            }
        }

        #input-row {
            display: flex;
            margin-top: 12px;
        }

        #userInput {
            flex: 1;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 1rem;
            background: #fff;
            color: #222;
        }

        #sendButton {
            margin-left: 8px;
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            background: #44b7fe;
            color: #fff;
            cursor: pointer;
            transition: background 0.2s;
        }

        #sendButton:active {
            background: #2ea0e0;
        }

        #sendButton:disabled {
            background: #b0c4de;
            cursor: not-allowed;
            opacity: 0.7;
        }



        @media only screen and (max-width: 768px) {
            /* 手机端背景设为黑色 */
            html, body {
                background: #000 !important;
            }
            
            #live2d-container {
                position: fixed;
                right: 0;
                bottom: 0;
                width: 100%;
                height: 100%;
                z-index: 5;
            }

            #chat-container {
                width: 90vw;
                left: 5vw;
                bottom: 5px;
                max-height: 60vh;
                height: 60vh;
                padding: 0;
                margin-bottom: 5px;
                /* 禁用容器尺寸过渡，避免影响输入区 */
                transition: none !important;
                background: transparent;
                box-shadow: none;
            }
            
            #chat-header {
                height: 40px;
                font-size: 0.9rem;
            }
            
            #chat-content-wrapper {
                padding: 12px;
                padding-top: 44px;
                /* 禁用内容区过渡，避免折叠时对子元素产生影响 */
                transition: none !important;
                background: rgba(249, 249, 249, 0.5);  /* Fluent 背景层 */
            }
            
            #text-input-area {
                padding: 8px;
                /* 输入区不参与任何过渡动画 */
                transition: none !important;
                background: rgba(255, 255, 255, 0.4);  /* Fluent Acrylic */
                border-top: 1px solid rgba(0, 0, 0, 0.06);  /* Fluent 分隔线 */
            }
            /* 输入区内部元素也不参与过渡，避免细微跳动 */
            #text-input-row,
            #textInputBox,
            #button-group {
                transition: none !important;
            }
            
            #textInputBox {
                font-size: 0.9rem;
                /* 移动端：按钮组高度 = 两个按钮(6px*2+内容) + gap(4px) */
                height: 62px; /* 保持移动端原有高度 */
            }
            
            #button-group {
                gap: 4px;
            }
            
            #textSendButton, #screenshotButton {
                padding: 6px 12px;
                font-size: 0.8rem;
                min-width: 70px;
            }
            
            .screenshot-item {
                width: 80px;
            }
            
            .screenshot-thumbnail {
                width: 80px;
                height: 60px;
            }
            
            #screenshots-title {
                font-size: 0.8rem;
            }
            
            #clear-all-screenshots {
                font-size: 0.7rem;
                padding: 2px 6px;
            }
            
            .screenshot-index {
                font-size: 0.65rem;
            }
            
            .message {
                font-size: 0.9rem;
                max-width: 85%;
            }

            /* 移动端显示拍照，隐藏截图 */
            .desktop-text {
                display: none;
            }
            
            .mobile-text {
                display: inline;
            }
        }

        @media only screen and (max-width: 768px) {
            /* 移动端：折叠（mobile-collapsed）时，聊天框高度为12vh */
            #chat-container.mobile-collapsed {
                height: 12vh;
            }
            /* 移动端：折叠（mobile-collapsed）时，切换按钮固定到左上角 */
            #chat-container.mobile-collapsed #toggle-chat-btn {
                left: 8px;
                right: auto;
                top: 8px;
                transform: none;
                position: relative;
            }
            /* 避免按钮覆盖输入区顶边，给输入区微小顶距 */
            #chat-container.mobile-collapsed #text-input-area {
                margin-top: 6px;
            }
        }
        
        @media only screen and (max-width: 768px) {
            /* 移动端：最小化仅折叠内容区，输入区常驻显示 */
            #chat-container.minimized #text-input-area {
                display: block;
            }
            
            /* 移动端：最小化时保持容器尺寸，让输入区可见可用 */
            #chat-container.minimized {
                width: 90vw;
                left: 5vw;
                bottom: 5px;
                height: auto;
                max-height: none;
                padding: 0;
                cursor: default;
                border-radius: 8px; /* 移动端保持矩形圆角 */
                animation: none; /* 移动端不需要呼吸效果 */
                background: transparent;
            }
        }
        
    </style>
</head>
<body>

<!-- 旧的按钮面板已迁移到浮动按钮系统（live2d.js），保留隐藏的旧按钮元素供功能触发使用 -->
<div id="sidebar" style="display: none;">
    <div id="sidebarbox">
        <button id="micButton" class="side-btn" data-i18n="voiceControl.startVoice">🎤 开始语音</button>
        <button id="muteButton" class="side-btn" disabled data-i18n="voiceControl.rest">⏸️ 休息一下</button>
        <button id="screenButton" class="side-btn" disabled data-i18n="voiceControl.screenShare">🖥️ 屏幕共享</button>
        <button id="stopButton" class="side-btn" disabled data-i18n="voiceControl.stopShare">🛑 停止共享</button>
        <button id="resetSessionButton" class="side-btn" data-i18n="voiceControl.leave">👋 请她离开</button>
        <button id="returnSessionButton" class="side-btn" data-i18n="voiceControl.return">🫴 请她回来</button>
        <div id="status"></div>
    </div>
</div>

<!-- Status 气泡框 - 将由 React 组件挂载 -->
<div id="status-toast"></div>
<!-- Modal 容器 - 将由 React 组件挂载 -->
<div id="modal-container" style="display: none;"></div>
<!-- ExampleButton 容器 -->
<div id="example-button-container" style="position: fixed; top: 20px; left: 20px; z-index: 99998; pointer-events: auto;"></div>
<div id="chat-container">
    <div id="chat-header">
        <span id="chat-title" data-i18n="chat.title">💬 对话</span>
    </div>
    <button id="toggle-chat-btn" data-i18n-title="common.minimize" title="最小化"><img src="/static/icons/minimize_icon.png" alt="最小化" data-i18n-alt="common.minimize" style="width: 24px; height: 24px; object-fit: contain; pointer-events: none;"></button>
    <div id="chat-tooltip" data-i18n="chat.tooltip">✨ 对话区</div>
    <div id="chat-content-wrapper">
        <div id="chatContainer"></div>
    </div>
    <div id="text-input-area">
        <div id="screenshot-thumbnail-container">
            <div id="screenshots-header">
                <span id="screenshots-title" data-i18n="chat.screenshotsTitle">📸 待发送截图</span> (<span id="screenshot-count">0</span>)
                <div id="clear-all-screenshots-container"></div>
            </div>
            <div id="screenshots-list">
                <!-- 截图项将动态添加到这里 -->
            </div>
        </div>
        <div id="text-input-row">
            <textarea id="textInputBox" data-i18n-placeholder="chat.textInputPlaceholder" placeholder="文字聊天模式...回车发送，Shift+回车换行" tabindex="0"></textarea>
            <div id="button-group">
                <div id="textSendButton-container"></div>
                <div id="screenshotButton-container"></div>
            </div>
        </div>
    </div>
</div>
<div id="live2d-container">
    <canvas id="live2d-canvas"></canvas>
</div>

<script>
    // 页面配置 - 从 URL 或 API 获取
    let lanlan_config = {
        lanlan_name: ""
    };
    window.lanlan_config = lanlan_config;
    let cubism4Model = "";
    
    // 异步获取页面配置
    async function loadPageConfig() {
        try {
            // 优先从 URL 获取 lanlan_name
            const urlParams = new URLSearchParams(window.location.search);
            let lanlanNameFromUrl = urlParams.get('lanlan_name') || "";
            
            // 从路径中提取 lanlan_name (例如 /{lanlan_name})
            if (!lanlanNameFromUrl) {
                const pathParts = window.location.pathname.split('/').filter(Boolean);
                if (pathParts.length > 0 && !['focus', 'api', 'static', 'templates'].includes(pathParts[0])) {
                    lanlanNameFromUrl = decodeURIComponent(pathParts[0]);
                }
            }
            
            // 从 API 获取配置（使用 RequestAPI）
            // 等待 request 和 RequestAPI 都初始化完成
            await window.ReactInit.waitForRequestInit();
            await window.ReactInit.waitForRequestAPIInit();
            const data = await window.RequestAPI.getPageConfig(lanlanNameFromUrl || undefined);
            
            if (data && data.success) {
                // 使用 URL 中的 lanlan_name（如果有），否则使用 API 返回的
                lanlan_config.lanlan_name = lanlanNameFromUrl || data.lanlan_name || "";
                window.lanlan_config = lanlan_config;
                cubism4Model = data.model_path || "";
                window.cubism4Model = cubism4Model;
                
                // 动态设置页面标题
                document.title = `${lanlan_config.lanlan_name} Terminal - Project N.E.K.O.`;
                
                console.log('页面配置加载成功:', { lanlan_name: lanlan_config.lanlan_name, model_path: cubism4Model });
                return true;
            } else {
                console.error('获取页面配置失败:', data.error);
                // 使用默认值
                lanlan_config.lanlan_name = "";
                cubism4Model = "";
                return false;
            }
        } catch (error) {
            console.error('加载页面配置时出错:', error);
            // 使用默认值
            lanlan_config.lanlan_name = "";
            cubism4Model = "";
            return false;
        }
    }
    
    // 标记配置是否已加载
    window.pageConfigReady = loadPageConfig();
</script>
<script>
    // Beacon功能 - 页面关闭时发送信号给服务器
    let beaconSent = false;
    
    // 缓存 RequestAPI 的 sendShutdownBeacon 方法引用（在页面加载时初始化）
    let cachedSendShutdownBeacon = null;

    function sendBeacon() {
        if (beaconSent) return; // 防止重复发送
        beaconSent = true;
        
        try {
            // 优先使用缓存的 RequestAPI.sendShutdownBeacon（如果已初始化）
            if (cachedSendShutdownBeacon) {
                // 调用缓存的函数（异步执行，不等待结果）
                cachedSendShutdownBeacon(true).catch(err => {
                    console.warn('RequestAPI.sendShutdownBeacon 调用失败:', err);
                });
                return;
            }
            
            // 如果 RequestAPI 在此时可用但未缓存，直接尝试使用
            if (window.RequestAPI && typeof window.RequestAPI.sendShutdownBeacon === 'function') {
                window.RequestAPI.sendShutdownBeacon(true).catch(err => {
                    console.warn('RequestAPI.sendShutdownBeacon 调用失败:', err);
                });
                return;
            }
            
            // 备用方案：直接使用 navigator.sendBeacon
            if (typeof navigator !== 'undefined' && navigator.sendBeacon) {
                const payload = JSON.stringify({
                    timestamp: Date.now(),
                    action: 'shutdown'
                });
                const success = navigator.sendBeacon('/api/beacon/shutdown', payload);
                if (success) {
                    console.log('Beacon信号已发送（使用 navigator.sendBeacon）');
                } else {
                    console.warn('navigator.sendBeacon 发送失败');
                }
            } else {
                console.warn('RequestAPI 未初始化且 navigator.sendBeacon 不可用，无法发送关闭信号');
            }
        } catch (e) {
            console.error('Beacon发送异常:', e);
        }
    }

    // 监听页面关闭事件
    window.addEventListener('beforeunload', sendBeacon);
    window.addEventListener('unload', sendBeacon);
</script>
<script>
    // 在页面加载时缓存 RequestAPI 的 sendShutdownBeacon 方法
    // 使用 DOMContentLoaded 和 load 事件确保在模块加载后检查
    function cacheRequestAPIShutdownBeacon() {
        // 检查 RequestAPI 是否已初始化
        if (window.RequestAPI && typeof window.RequestAPI.sendShutdownBeacon === 'function') {
            cachedSendShutdownBeacon = window.RequestAPI.sendShutdownBeacon.bind(window.RequestAPI);
            console.log('[Beacon] RequestAPI.sendShutdownBeacon 已缓存');
            return true;
        }
        return false;
    }
    
    // 立即检查一次（可能模块已经加载完成）
    if (cacheRequestAPIShutdownBeacon()) {
        // 已经缓存，无需继续
    } else {
        // 模块可能还在加载，使用事件监听和轮询
        let checkCount = 0;
        const maxChecks = 50; // 最多检查 50 次（约 5 秒）
        
        const checkInterval = setInterval(() => {
            checkCount++;
            if (cacheRequestAPIShutdownBeacon() || checkCount >= maxChecks) {
                clearInterval(checkInterval);
            }
        }, 100);
        
        // DOMContentLoaded 时也检查一次
        document.addEventListener('DOMContentLoaded', () => {
            cacheRequestAPIShutdownBeacon();
        });
        
        // load 事件时最终检查
        window.addEventListener('load', () => {
            cacheRequestAPIShutdownBeacon();
            clearInterval(checkInterval);
        });
    }
</script>
<script src="/static/libs/live2dcubismcore.min.js"></script>  <!-- Cubism 4核心库（支持Cubism 3/4模型） -->
<script>
    // 全局菜单跟踪机制 - 必须在所有其他脚本之前定义
    // 用于跟踪当前是否有活动的菜单（麦克风列表、Agent面板、侧边栏等）
    window.activeMenuCount = 0;
    
    // 辅助函数：标记菜单打开
    window.markMenuOpen = function() {
        window.activeMenuCount++;
    };
    
    // 辅助函数：标记菜单关闭
    window.markMenuClosed = function() {
        window.activeMenuCount = Math.max(0, window.activeMenuCount - 1);
    };
    
    // 页面间通信：监听来自模型设置页面的消息
    async function handlePageMessage(event) {
        if (event.key === 'nekopage_message') {
            try {
                const message = JSON.parse(event.newValue);
                if (message && message.action) {
                    switch (message.action) {
                        case 'hide_main_ui':
                            console.log('接收到隐藏主界面命令');
                            hideMainUI();
                            break;
                        case 'show_main_ui':
                            console.log('接收到显示主界面命令');
                            await showMainUI();
                            break;
                        case 'reload_model_parameters':
                            console.log('接收到重新加载模型参数命令');
                            await reloadModelParameters();
                            break;
                    }
                }
            } catch (e) {
                console.log('解析页面消息失败:', e);
            }
        }
    }
    
    // 隐藏主界面的函数
    function hideMainUI() {
        // 隐藏主要UI元素
        const live2dContainer = document.getElementById('live2d-container');
        const chatContainer = document.getElementById('chat-container');
        
        if (live2dContainer) {
            live2dContainer.style.display = 'none';
        }
        if (chatContainer) {
            chatContainer.style.display = 'none';
        }
        
        // 可以添加一个标记，记录当前隐藏状态
        document.body.setAttribute('data-ui-hidden', 'true');
    }
    
    // 显示主界面的函数（仅用于弹出窗口关闭时恢复UI）
    // 记录页面加载时间，防止初始加载时误触发模型重新加载
    const pageLoadTime = Date.now();
    
    async function showMainUI() {
        // 防止在初始加载时（3秒内）触发模型检查
        const now = Date.now();
        if (now - pageLoadTime < 3000) {
            return;
        }
        
        // 显示主要UI元素
        const live2dContainer = document.getElementById('live2d-container');
        const chatContainer = document.getElementById('chat-container');
        
        if (live2dContainer) {
            live2dContainer.style.display = '';
        }
        if (chatContainer) {
            chatContainer.style.display = '';
        }
        
        // 移除隐藏状态标记
        document.body.removeAttribute('data-ui-hidden');
        
        // 检查模型是否需要重新加载（弹出窗口可能修改了模型配置）
        try {
            console.log('检查模型配置是否有更新...');
            
            // 等待 RequestAPI 初始化
            if (window.ReactInit && window.ReactInit.waitForRequestAPIInit) {
                await window.ReactInit.waitForRequestAPIInit();
            }
            
            // 1. 获取当前角色名称
            let currentLanlanName = lanlan_config.lanlan_name;
            console.log('BEFORE currentLanlanName: ', currentLanlanName);
            
            // 2. 获取最新的角色配置（使用 RequestAPI）
            const charactersData = await window.RequestAPI.getCharacters();

            // 确保 lanlan_config.lanlan_name 更新到 chara_manager.html 当前选中的猫娘
            currentLanlanName = lanlan_config.lanlan_name = charactersData['当前猫娘'];
            console.log('AFTER currentLanlanName: ', currentLanlanName);
            
            // 从猫娘配置中获取当前角色的 live2d 模型名称
            const catgirlConfig = charactersData['猫娘']?.[currentLanlanName];
            if (!catgirlConfig) {
                console.warn(`未找到角色 ${currentLanlanName} 的配置，跳过模型检查`);
                return;
            }
            const newModelName = catgirlConfig.live2d || 'mao_pro';
            console.log('AFTER newModelName: ', newModelName);
            
            // 3. 获取所有可用模型列表（使用 RequestAPI）
            const models = await window.RequestAPI.getLive2DModels();
            
            // 4. 根据模型名称查找对应的模型路径
            const modelInfo = models.find(m => m.name === newModelName);
            if (!modelInfo) {
                console.warn(`未找到模型 ${newModelName}，跳过模型检查`);
                return;
            }
            const newModelPath = modelInfo.path;
            console.log('AFTER newModelPath: ', newModelPath);
            
            // 5. 检查当前加载的模型路径（优先使用 _lastLoadedModelPath）
            const currentModel = window.live2dManager?.getCurrentModel();
            let currentModelPath = '';
            if (window.live2dManager?._lastLoadedModelPath) {
                currentModelPath = window.live2dManager._lastLoadedModelPath;
            } else if (currentModel && currentModel.url) {
                currentModelPath = currentModel.url;
            } else if (window.live2dManager?.modelRootPath && window.live2dManager?.modelName) {
                currentModelPath = `${window.live2dManager.modelRootPath}/${window.live2dManager.modelName}.model3.json`;
            }
            
            // 6. 总是重新加载用户偏好（位置、缩放等可能被修改）
            const preferences = await window.live2dManager.loadUserPreferences();
            let modelPreferences = null;
            if (preferences && preferences.length > 0) {
                modelPreferences = preferences.find(p => p && p.model_path === newModelPath);
            }
            
            // 7. 比较模型路径，判断是否需要完全重新加载模型（使用更准确的路径比较）
            let needReload = false;
            if (!currentModelPath) {
                needReload = true;
            } else {
                // 标准化路径进行比较
                const normalizePath = (path) => {
                    if (!path) return '';
                    return path.split('#')[0].split('?')[0].toLowerCase();
                };
                const normalizedCurrent = normalizePath(currentModelPath);
                const normalizedNew = normalizePath(newModelPath);
                
                // 提取模型名称进行比较
                const currentModelName = normalizedCurrent.split('/').filter(Boolean).pop()?.replace('.model3.json', '') || '';
                const newModelNameCompare = normalizedNew.split('/').filter(Boolean).pop()?.replace('.model3.json', '') || '';
                
                if (normalizedCurrent === normalizedNew) {
                    needReload = false;
                } else if (currentModelName && newModelNameCompare && currentModelName === newModelNameCompare) {
                    needReload = false;
                } else {
                    needReload = true;
                }
            }
            
            if (needReload) {
                // 模型改变了，需要完全重新加载
                console.log(`检测到模型变化，重新加载: ${newModelPath}`);
                console.log(`当前模型: ${currentModelPath}`);
                console.log(`新模型: ${newModelPath}`);
                
                await window.live2dManager.loadModel(newModelPath, {
                    preferences: modelPreferences,
                    isMobile: window.innerWidth <= 768
                });
                
                // 更新全局引用
                window.LanLan1.live2dModel = window.live2dManager.getCurrentModel();
                window.LanLan1.currentModel = window.live2dManager.getCurrentModel();
                window.LanLan1.emotionMapping = window.live2dManager.getEmotionMapping();
                
                console.log('模型已重新加载');
            } else {
                // 模型未变，但需要更新位置和缩放设置
                console.log('模型未改变，但重新应用用户偏好设置');
                
                if (modelPreferences && currentModel) {
                    // 应用位置设置
                    if (modelPreferences.position) {
                        currentModel.x = modelPreferences.position.x || currentModel.x;
                        currentModel.y = modelPreferences.position.y || currentModel.y;
                        console.log('已应用位置设置:', modelPreferences.position);
                    }
                    
                    // 应用缩放设置
                    if (modelPreferences.scale) {
                        currentModel.scale.set(
                            modelPreferences.scale.x || currentModel.scale.x,
                            modelPreferences.scale.y || currentModel.scale.y
                        );
                        console.log('已应用缩放设置:', modelPreferences.scale);
                    }
                    
                    // 应用保存的模型参数
                    if (modelPreferences.parameters && currentModel.internalModel && currentModel.internalModel.coreModel) {
                        window.live2dManager.applyModelParameters(currentModel, modelPreferences.parameters);
                        console.log('已应用保存的模型参数');
                    }
                } else {
                    console.log('无需应用偏好设置（未找到或模型未加载）');
                }
            }
            
        } catch (error) {
            console.error('检查/重新加载模型时出错:', error);
            // 出错时不影响UI显示
        }
    }
    
    // 重新加载模型参数（用于参数编辑器保存后）
    async function reloadModelParameters() {
        try {
            console.log('=== 开始重新加载模型参数 ===');
            const currentModel = window.live2dManager?.getCurrentModel();
            if (!currentModel) {
                console.log('模型未加载，跳过参数重新加载');
                return;
            }
            
            // 获取当前模型路径（尝试多种方式）
            let currentModelPath = '';
            
            // 方式1: 从live2dManager的_lastLoadedModelPath获取（最可靠）
            if (window.live2dManager?._lastLoadedModelPath) {
                currentModelPath = window.live2dManager._lastLoadedModelPath;
                console.log('使用 _lastLoadedModelPath:', currentModelPath);
            }
            // 方式2: 从模型的url获取
            else if (currentModel.url) {
                currentModelPath = currentModel.url;
                console.log('使用 currentModel.url:', currentModelPath);
            }
            // 方式3: 从modelRootPath和modelName构建
            else if (window.live2dManager?.modelRootPath && window.live2dManager?.modelName) {
                currentModelPath = `${window.live2dManager.modelRootPath}/${window.live2dManager.modelName}.model3.json`;
                console.log('使用 modelRootPath + modelName:', currentModelPath);
            }
            // 方式4: 从cubism4Model获取
            else if (typeof cubism4Model !== 'undefined' && cubism4Model) {
                currentModelPath = cubism4Model;
                console.log('使用 cubism4Model:', currentModelPath);
            }
            
            if (!currentModelPath) {
                console.warn('无法确定当前模型路径，跳过参数重新加载');
                console.log('live2dManager状态:', {
                    hasManager: !!window.live2dManager,
                    _lastLoadedModelPath: window.live2dManager?._lastLoadedModelPath,
                    modelRootPath: window.live2dManager?.modelRootPath,
                    modelName: window.live2dManager?.modelName,
                    currentModelUrl: currentModel?.url
                });
                return;
            }
            
            console.log('当前模型路径:', currentModelPath);
            
            // 重新加载用户偏好
            const preferences = await window.live2dManager.loadUserPreferences();
            console.log('加载到的偏好设置数量:', preferences.length);
            console.log('所有偏好设置的路径:', preferences.map(p => p?.model_path).filter(Boolean));
            
            // 尝试多种匹配方式
            let modelPreferences = null;
            
            // 首先尝试精确匹配
            modelPreferences = preferences.find(p => {
                if (!p || !p.model_path) return false;
                return p.model_path === currentModelPath;
            });
            
            if (modelPreferences) {
                console.log('找到精确匹配的偏好设置');
            } else {
                // 尝试文件名匹配
                const currentFileName = currentModelPath.split('/').pop() || '';
                console.log('尝试文件名匹配，当前文件名:', currentFileName);
                
                modelPreferences = preferences.find(p => {
                    if (!p || !p.model_path) return false;
                    const prefFileName = p.model_path.split('/').pop() || '';
                    if (currentFileName && prefFileName && currentFileName === prefFileName) {
                        console.log('文件名匹配成功:', p.model_path);
                        return true;
                    }
                    return false;
                });
            }
            
            // 如果还是没找到，尝试通过模型名称匹配
            if (!modelPreferences && window.live2dManager?.modelName) {
                const modelName = window.live2dManager.modelName;
                console.log('尝试模型名称匹配:', modelName);
                modelPreferences = preferences.find(p => {
                    if (!p || !p.model_path) return false;
                    if (p.model_path.includes(modelName)) {
                        console.log('模型名称匹配成功:', p.model_path);
                        return true;
                    }
                    return false;
                });
            }
            
            // 如果还是没找到，尝试部分匹配
            if (!modelPreferences) {
                console.log('尝试部分匹配...');
                const currentPathParts = currentModelPath.split('/').filter(p => p);
                modelPreferences = preferences.find(p => {
                    if (!p || !p.model_path) return false;
                    const prefPathParts = p.model_path.split('/').filter(p => p);
                    // 检查是否有共同的部分
                    const commonParts = currentPathParts.filter(part => prefPathParts.includes(part));
                    if (commonParts.length >= 2) { // 至少有两个共同部分
                        console.log('部分匹配成功:', p.model_path, '共同部分:', commonParts);
                        return true;
                    }
                    return false;
                });
            }
            
            if (modelPreferences) {
                console.log('找到匹配的偏好设置:', modelPreferences.model_path);
                console.log('是否有参数:', !!modelPreferences.parameters);
                
                if (modelPreferences.parameters) {
                    const paramCount = Object.keys(modelPreferences.parameters).length;
                    console.log('参数数量:', paramCount);
                    console.log('参数示例:', Object.keys(modelPreferences.parameters).slice(0, 5));
                    
                    // 应用保存的参数
                    if (currentModel.internalModel && currentModel.internalModel.coreModel) {
                        window.live2dManager.applyModelParameters(currentModel, modelPreferences.parameters);
                        console.log('✓ 已重新应用保存的模型参数，参数数量:', paramCount);
                    } else {
                        console.warn('模型未完全加载，无法应用参数');
                    }
                } else {
                    console.log('偏好设置中没有参数数据');
                }
            } else {
                console.warn('未找到匹配的偏好设置');
                console.log('当前模型路径:', currentModelPath);
                console.log('所有可用偏好设置的路径:');
                preferences.forEach((p, i) => {
                    console.log(`  [${i}] ${p?.model_path || 'N/A'}`);
                });
            }
            
            console.log('=== 重新加载模型参数完成 ===');
        } catch (error) {
            console.error('重新加载模型参数失败:', error);
            console.error('错误堆栈:', error.stack);
        }
    }
    
    // 注册localStorage事件监听器
    window.addEventListener('storage', handlePageMessage);
    
    // 页面可见性变化时检查参数更新（用户从其他页面返回时）
    let lastParameterCheckTime = 0;
    document.addEventListener('visibilitychange', async () => {
        const now = Date.now();
        // 防止在初始加载时（3秒内）触发
        if (document.visibilityState === 'visible' && now - pageLoadTime > 3000 && now - lastParameterCheckTime > 1000) {
            lastParameterCheckTime = now;
            await reloadModelParameters();
        }
    });
    
    // 页面获得焦点时也检查（备用机制）
    window.addEventListener('focus', async () => {
        const now = Date.now();
        // 防止在初始加载时（3秒内）触发
        if (now - pageLoadTime > 3000 && now - lastParameterCheckTime > 1000) {
            lastParameterCheckTime = now;
            await reloadModelParameters();
        }
    });
    
    // 页面加载完成后，等待模型加载完成后再检查参数
    // 使用MutationObserver或定时器检查模型是否已加载
    let modelLoadCheckInterval = null;
    function startModelLoadCheck() {
        if (modelLoadCheckInterval) return;
        
        modelLoadCheckInterval = setInterval(async () => {
            const currentModel = window.live2dManager?.getCurrentModel();
            if (currentModel && currentModel.internalModel && currentModel.internalModel.coreModel) {
                // 模型已加载，停止检查
                clearInterval(modelLoadCheckInterval);
                modelLoadCheckInterval = null;
                
                // 等待一小段时间确保模型完全初始化
                setTimeout(async () => {
                    console.log('模型已加载，检查参数更新...');
                    await reloadModelParameters();
                }, 500);
            }
        }, 500);
        
        // 30秒后停止检查（避免无限检查）
        setTimeout(() => {
            if (modelLoadCheckInterval) {
                clearInterval(modelLoadCheckInterval);
                modelLoadCheckInterval = null;
            }
        }, 30000);
    }
    
    // 页面加载时开始检查
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', startModelLoadCheck);
    } else {
        startModelLoadCheck();
    }
    
    // 页面卸载时清理监听器
    window.addEventListener('beforeunload', () => {
        window.removeEventListener('storage', handlePageMessage);
        if (modelLoadCheckInterval) {
            clearInterval(modelLoadCheckInterval);
        }
    });
</script>
<script src="/static/libs/live2d.min.js"></script>  <!-- Cubism 2.1核心库（支持旧模型） -->
<script src="/static/libs/pixi.min.js"></script>  <!-- PixiJS v7 CDN -->
<script src="/static/libs/index.min.js"></script>  <!-- pixi-live2d-display v0.5.0-ls-6（RaSan147 fork，支持v7） -->
<!-- i18next 已在 head 中加载，这里不再需要 -->
<script src="/static/common_ui.js"></script>
<script>
    // 等待配置加载完成后再加载 Live2D 和 app.js
    (async function() {
        try {
            // 等待配置加载完成
            await window.pageConfigReady;
            
            // 动态加载 live2d 模块（按顺序加载拆分后的文件）
            const live2dModules = [
                '/static/live2d-core.js',
                '/static/live2d-emotion.js',
                '/static/live2d-model.js',
                '/static/live2d-interaction.js',
                '/static/live2d-ui-buttons.js',
                '/static/live2d-ui-popup.js',
                '/static/live2d-ui-hud.js',
                '/static/live2d-ui-drag.js',
                '/static/live2d-init.js'
            ];
            
            // 按顺序加载脚本的辅助函数
            async function loadScriptsSequentially(scripts) {
                for (const src of scripts) {
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = src;
                        script.onload = resolve;
                        script.onerror = reject;
                        document.body.appendChild(script);
                    });
                }
            }
            
            // 加载所有 live2d 模块
            await loadScriptsSequentially(live2dModules);
            
            // 等待 StatusToast 组件就绪（最多等待 2 秒）
            const waitForStatusToast = () => {
                return new Promise((resolve) => {
                    if (typeof window.showStatusToast === 'function' && 
                        window.showStatusToast.toString().includes('showToast')) {
                        // 检查是否是 React 组件提供的函数（不是临时队列函数）
                        console.log('[App] StatusToast 组件已就绪');
                        resolve(true);
                        return;
                    }
                    
                    // 监听就绪事件
                    const timeout = setTimeout(() => {
                        console.warn('[App] StatusToast 组件等待超时，继续加载 app.js');
                        resolve(false);
                    }, 2000);
                    
                    window.addEventListener('statusToastReady', () => {
                        clearTimeout(timeout);
                        console.log('[App] StatusToast 组件就绪事件触发');
                        resolve(true);
                    }, { once: true });
                });
            };
            
            await waitForStatusToast();
            
            // 等待 live2d 模块加载完成后再加载 app.js
            const appScript = document.createElement('script');
            appScript.src = '/static/app.js';
            document.body.appendChild(appScript);
        } catch (error) {
            console.error('加载脚本时出错:', error);
        }
    })();
</script>

<script>
  // 对话区提示框逻辑 - 仅在第一次访问时显示
  (function() {
    
    // 等待 DOM 和所有脚本完全加载
    window.addEventListener('load', function() {
      // 再等待一小段时间，确保 common_ui.js 的事件监听器已设置
      setTimeout(function() {
        const chatTooltip = document.getElementById('chat-tooltip');
        const textInputBox = document.getElementById('textInputBox');
        const chatContainer = document.getElementById('chat-container');
        const toggleBtn = document.getElementById('toggle-chat-btn');
        let autoCollapseTimer = null;
        
        // 检查是否是第一次访问（只影响提示框显示）
        const hasVisitedBefore = localStorage.getItem('chat_tooltip_shown');
        
        if (chatTooltip && textInputBox && chatContainer && toggleBtn) {
          // 提示框只在第一次访问时显示
          if (!hasVisitedBefore) {
            chatTooltip.classList.remove('hidden');
            localStorage.setItem('chat_tooltip_shown', 'true');
          } else {
            chatTooltip.classList.add('hidden');
          }
          
          // 监听文本框焦点事件
          const handleFocus = () => {
            // 用户聚焦了文本框，立即隐藏提示并取消自动折叠
            if (autoCollapseTimer) {
              clearTimeout(autoCollapseTimer);
              autoCollapseTimer = null;
              console.log('用户聚焦文本框，取消自动折叠');
            }
            chatTooltip.classList.add('hidden');
            // 移除监听器，因为已经完成任务
            textInputBox.removeEventListener('focus', handleFocus);
          };
          
          // 监听手动折叠按钮点击事件
          const handleToggleClick = () => {
            // 用户手动点击了折叠按钮，取消自动折叠
            if (autoCollapseTimer) {
              clearTimeout(autoCollapseTimer);
              autoCollapseTimer = null;
              console.log('用户手动折叠对话区，取消自动折叠');
            }
            chatTooltip.classList.add('hidden');
            // 移除监听器，因为已经完成任务
            toggleBtn.removeEventListener('click', handleToggleClick);
          };
          
          // 注册事件监听器
          textInputBox.addEventListener('focus', handleFocus);
          toggleBtn.addEventListener('click', handleToggleClick);
          
          // 每次页面加载都执行：5秒后自动折叠整个对话区（除非有活动菜单）
          autoCollapseTimer = setTimeout(() => {
            // 检查是否有活动菜单，如果有则不自动折叠
            if (window.activeMenuCount > 0) {
              console.log('检测到活动菜单，跳过自动折叠');
              return;
            }
            
            // 先隐藏提示框（带动画）
            chatTooltip.classList.add('hidden');
            // 等待提示框动画完成后再折叠对话区
            setTimeout(() => {
              // 再次检查是否有活动菜单
              if (window.activeMenuCount > 0) {
                console.log('检测到活动菜单，跳过自动折叠');
                return;
              }
              // 直接模拟点击事件
              toggleBtn.click();
              console.log('自动折叠对话区');
            }, 300);
          }, 5000);
          
          console.log('页面加载完成，5秒后将自动折叠对话区（除非有活动菜单）');
        }
      }, 100); // 100ms 延迟确保所有初始化完成
    });
  })();
</script>
</body>
</html>
